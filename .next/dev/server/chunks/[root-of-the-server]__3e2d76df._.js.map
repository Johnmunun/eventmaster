{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///H:/React_projets/EventMaster/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n// Empêche Prisma d'être chargé dans le runtime edge\nif (typeof window !== \"undefined\") {\n  throw new Error(\"❌ Prisma ne peut pas être utilisé dans le frontend.\");\n}\n\nif (process.env.NEXT_RUNTIME === \"edge\") {\n  throw new Error(\"❌ Prisma ne peut pas être utilisé dans le runtime Edge.\");\n}\n\nexport const db =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log:\n      process.env.NODE_ENV === 'development'\n        ? ['error', 'warn']\n        : ['error'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIxB,oDAAoD;AACpD;;AAIA;;AAIO,MAAM,KACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KACE,uCACI;QAAC;QAAS;KAAO,GACjB;AACR;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///H:/React_projets/EventMaster/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport Credentials from \"next-auth/providers/credentials\"\nimport Google from \"next-auth/providers/google\"\nimport { db } from \"@/lib/db\"\nimport bcrypt from \"bcryptjs\"\nimport dotenv from \"dotenv\"\n\n// Charger les variables d'environnement\ndotenv.config({ path: '.env' })\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  adapter: PrismaAdapter(db) as any,\n  providers: [\n    Credentials({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          throw new Error(\"Email et mot de passe requis\")\n        }\n\n        const user = await db.user.findUnique({\n          where: {\n            email: credentials.email as string\n          }\n        })\n\n        if (!user || !user.password) {\n          throw new Error(\"Email ou mot de passe incorrect\")\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password as string,\n          user.password\n        )\n\n        if (!isPasswordValid) {\n          throw new Error(\"Email ou mot de passe incorrect\")\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image,\n          role: user.role,\n        }\n      }\n    }),\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID || \"\",\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET || \"\",\n    })\n  ],\n  session: {\n    strategy: \"jwt\",\n  },\n  pages: {\n    signIn: \"/login\",\n    signOut: \"/\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id\n        token.role = (user as any).role\n      }\n      return token\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string\n        session.user.role = token.role as string\n      }\n      return session\n    },\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  trustHost: true, // Nécessaire pour Next.js 16\n})\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;AAEA,wCAAwC;AACxC,kJAAM,CAAC,MAAM,CAAC;IAAE,MAAM;AAAO;AAEtB,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,kKAAQ,EAAC;IAC1D,SAAS,IAAA,uKAAa,EAAC,iHAAE;IACzB,WAAW;QACT,IAAA,uMAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,OAAO,MAAM,iHAAE,CAAC,IAAI,CAAC,UAAU,CAAC;oBACpC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,kBAAkB,MAAM,8IAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,MAAM,IAAI,MAAM;gBAClB;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;QACA,IAAA,kMAAM,EAAC;YACL,UAAU,QAAQ,GAAG,CAAC,gBAAgB,IAAI;YAC1C,cAAc,QAAQ,GAAG,CAAC,oBAAoB,IAAI;QACpD;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;YACjC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;IACnC,WAAW;AACb"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///H:/React_projets/EventMaster/lib/imagekit.ts"],"sourcesContent":["import ImageKit from \"imagekit\"\r\n\r\n// Configuration ImageKit\r\nconst imagekit = new ImageKit({\r\n  publicKey: process.env.IMAGEKIT_PUBLIC_KEY || \"\",\r\n  privateKey: process.env.IMAGEKIT_PRIVATE_KEY || \"\",\r\n  urlEndpoint: process.env.IMAGEKIT_URL_ENDPOINT || \"\",\r\n})\r\n\r\nexport interface UploadOptions {\r\n  file: Buffer | string // Buffer pour fichier, string pour base64\r\n  fileName: string\r\n  folder?: string\r\n  tags?: string[]\r\n}\r\n\r\n/**\r\n * Upload un fichier sur ImageKit\r\n */\r\nexport async function uploadToImageKit(options: UploadOptions): Promise<{\r\n  url: string\r\n  fileId: string\r\n  thumbnailUrl: string\r\n}> {\r\n  try {\r\n    const uploadOptions: any = {\r\n      file: options.file,\r\n      fileName: options.fileName,\r\n      folder: options.folder || \"/qrcodes\",\r\n      tags: options.tags || [\"qrcode\", \"eventmaster\"],\r\n    }\r\n\r\n    const result = await imagekit.upload(uploadOptions)\r\n\r\n    return {\r\n      url: result.url,\r\n      fileId: result.fileId,\r\n      thumbnailUrl: result.thumbnailUrl || result.url,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Erreur lors de l'upload ImageKit:\", error)\r\n    throw new Error(\"Impossible d'uploader l'image sur ImageKit\")\r\n  }\r\n}\r\n\r\n/**\r\n * Supprimer un fichier d'ImageKit\r\n */\r\nexport async function deleteFromImageKit(fileId: string): Promise<boolean> {\r\n  try {\r\n    await imagekit.deleteFile(fileId)\r\n    return true\r\n  } catch (error) {\r\n    console.error(\"Erreur lors de la suppression ImageKit:\", error)\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Obtenir l'URL d'une image avec transformations\r\n */\r\nexport function getImageKitUrl(\r\n  fileId: string,\r\n  transformations?: {\r\n    width?: number\r\n    height?: number\r\n    quality?: number\r\n    format?: string\r\n  }\r\n): string {\r\n  const urlEndpoint = process.env.IMAGEKIT_URL_ENDPOINT || \"\"\r\n  \r\n  // ImageKit peut utiliser soit le fileId, soit le path\r\n  // On essaie d'abord avec le fileId directement\r\n  let url = `${urlEndpoint}/${fileId}`\r\n  \r\n  // Si le fileId contient déjà un chemin complet, utiliser directement\r\n  if (fileId.startsWith(\"http\")) {\r\n    url = fileId\r\n  } else if (fileId.includes(\"/\")) {\r\n    // Si c'est un chemin relatif\r\n    url = `${urlEndpoint}${fileId.startsWith(\"/\") ? \"\" : \"/\"}${fileId}`\r\n  }\r\n  \r\n  if (transformations) {\r\n    const params: string[] = []\r\n    if (transformations.width) params.push(`w-${transformations.width}`)\r\n    if (transformations.height) params.push(`h-${transformations.height}`)\r\n    if (transformations.quality) params.push(`q-${transformations.quality}`)\r\n    if (transformations.format) params.push(`f-${transformations.format}`)\r\n    \r\n    if (params.length > 0) {\r\n      // ImageKit utilise le format: ?tr=w-800,q-90,f-png\r\n      url += (url.includes(\"?\") ? \"&\" : \"?\") + `tr=${params.join(\",\")}`\r\n    }\r\n  }\r\n  \r\n  return url\r\n}\r\n\r\nexport { imagekit }\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA,yBAAyB;AACzB,MAAM,WAAW,IAAI,sJAAQ,CAAC;IAC5B,WAAW,QAAQ,GAAG,CAAC,mBAAmB,IAAI;IAC9C,YAAY,QAAQ,GAAG,CAAC,oBAAoB,IAAI;IAChD,aAAa,QAAQ,GAAG,CAAC,qBAAqB,IAAI;AACpD;AAYO,eAAe,iBAAiB,OAAsB;IAK3D,IAAI;QACF,MAAM,gBAAqB;YACzB,MAAM,QAAQ,IAAI;YAClB,UAAU,QAAQ,QAAQ;YAC1B,QAAQ,QAAQ,MAAM,IAAI;YAC1B,MAAM,QAAQ,IAAI,IAAI;gBAAC;gBAAU;aAAc;QACjD;QAEA,MAAM,SAAS,MAAM,SAAS,MAAM,CAAC;QAErC,OAAO;YACL,KAAK,OAAO,GAAG;YACf,QAAQ,OAAO,MAAM;YACrB,cAAc,OAAO,YAAY,IAAI,OAAO,GAAG;QACjD;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;QACnD,MAAM,IAAI,MAAM;IAClB;AACF;AAKO,eAAe,mBAAmB,MAAc;IACrD,IAAI;QACF,MAAM,SAAS,UAAU,CAAC;QAC1B,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO;IACT;AACF;AAKO,SAAS,eACd,MAAc,EACd,eAKC;IAED,MAAM,cAAc,QAAQ,GAAG,CAAC,qBAAqB,IAAI;IAEzD,sDAAsD;IACtD,+CAA+C;IAC/C,IAAI,MAAM,GAAG,YAAY,CAAC,EAAE,QAAQ;IAEpC,qEAAqE;IACrE,IAAI,OAAO,UAAU,CAAC,SAAS;QAC7B,MAAM;IACR,OAAO,IAAI,OAAO,QAAQ,CAAC,MAAM;QAC/B,6BAA6B;QAC7B,MAAM,GAAG,cAAc,OAAO,UAAU,CAAC,OAAO,KAAK,MAAM,QAAQ;IACrE;IAEA,IAAI,iBAAiB;QACnB,MAAM,SAAmB,EAAE;QAC3B,IAAI,gBAAgB,KAAK,EAAE,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,gBAAgB,KAAK,EAAE;QACnE,IAAI,gBAAgB,MAAM,EAAE,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,gBAAgB,MAAM,EAAE;QACrE,IAAI,gBAAgB,OAAO,EAAE,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,gBAAgB,OAAO,EAAE;QACvE,IAAI,gBAAgB,MAAM,EAAE,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,gBAAgB,MAAM,EAAE;QAErE,IAAI,OAAO,MAAM,GAAG,GAAG;YACrB,mDAAmD;YACnD,OAAO,CAAC,IAAI,QAAQ,CAAC,OAAO,MAAM,GAAG,IAAI,CAAC,GAAG,EAAE,OAAO,IAAI,CAAC,MAAM;QACnE;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///H:/React_projets/EventMaster/app/api/qrcodes/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { auth } from \"@/lib/auth\"\nimport { db } from \"@/lib/db\"\nimport { z } from \"zod\"\nimport { Prisma } from \"@prisma/client\"\nimport QRCode from \"qrcode\"\nimport crypto from \"crypto\"\nimport { uploadToImageKit } from \"@/lib/imagekit\"\n\nconst createQRCodeSchema = z.object({\n  name: z.string().min(1, \"Le nom est requis\").max(100, \"Le nom est trop long\"),\n  eventId: z.string().min(1, \"L'événement est requis\").optional(),\n  guestId: z.string().optional(),\n  type: z.enum([\"EVENT\", \"GUEST\", \"CUSTOM\"]),\n  folderId: z.string().optional(),\n  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, \"Couleur invalide\").optional(),\n  backgroundColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/, \"Couleur de fond invalide\").optional(),\n  data: z.record(z.any()).optional(), // Données personnalisées pour le QR code\n})\n\n// POST - Créer un QR code\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await auth()\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { success: false, error: \"Non authentifié\" },\n        { status: 401 }\n      )\n    }\n\n    const userId = session.user.id\n\n    // Parser le body\n    let body\n    try {\n      body = await request.json()\n    } catch (parseError) {\n      return NextResponse.json(\n        { success: false, error: \"Format de requête invalide\" },\n        { status: 400 }\n      )\n    }\n\n    // Validation\n    const validatedData = createQRCodeSchema.parse(body)\n\n    // Vérifier que l'événement appartient à l'utilisateur si fourni\n    if (validatedData.eventId) {\n      const event = await db.event.findFirst({\n        where: {\n          id: validatedData.eventId,\n          userId: userId,\n        }\n      })\n\n      if (!event) {\n        return NextResponse.json(\n          { success: false, error: \"Événement non trouvé ou non autorisé\" },\n          { status: 404 }\n        )\n      }\n    }\n\n    // Vérifier que l'invité appartient à l'utilisateur si fourni\n    if (validatedData.guestId) {\n      const guest = await db.guest.findFirst({\n        where: {\n          id: validatedData.guestId,\n          userId: userId,\n        }\n      })\n\n      if (!guest) {\n        return NextResponse.json(\n          { success: false, error: \"Invité non trouvé ou non autorisé\" },\n          { status: 404 }\n        )\n      }\n    }\n\n    // Vérifier que le dossier appartient à l'utilisateur si fourni\n    if (validatedData.folderId) {\n      const folder = await db.folder.findFirst({\n        where: {\n          id: validatedData.folderId,\n          userId: userId,\n        }\n      })\n\n      if (!folder) {\n        return NextResponse.json(\n          { success: false, error: \"Dossier non trouvé ou non autorisé\" },\n          { status: 404 }\n        )\n      }\n    }\n\n    // Générer un code unique pour le QR code\n    let code: string\n    let isUnique = false\n    let attempts = 0\n    const maxAttempts = 10\n\n    while (!isUnique && attempts < maxAttempts) {\n      code = crypto.randomBytes(16).toString('hex')\n      const existing = await db.qrCode.findUnique({\n        where: { code }\n      })\n      if (!existing) {\n        isUnique = true\n      }\n      attempts++\n    }\n\n    if (!isUnique) {\n      return NextResponse.json(\n        { success: false, error: \"Impossible de générer un code unique. Veuillez réessayer.\" },\n        { status: 500 }\n      )\n    }\n\n    // Déterminer l'URL à encoder dans le QR code\n    let qrData: string\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || \"http://localhost:3000\"\n\n    if (validatedData.type === \"GUEST\" && validatedData.guestId) {\n      // QR code pour un invité spécifique\n      qrData = `${baseUrl}/scan/${code}`\n    } else if (validatedData.type === \"EVENT\" && validatedData.eventId) {\n      // QR code pour un événement\n      qrData = `${baseUrl}/event/${validatedData.eventId}/scan/${code}`\n    } else {\n      // QR code personnalisé\n      qrData = validatedData.data?.url || `${baseUrl}/scan/${code}`\n    }\n\n    // Générer le QR code en base64\n    const qrCodeOptions = {\n      color: {\n        dark: validatedData.color || \"#000000\",\n        light: validatedData.backgroundColor || \"#FFFFFF\",\n      },\n      errorCorrectionLevel: 'H' as const,\n      type: 'image/png' as const,\n      quality: 0.92,\n      margin: 1,\n      width: 512,\n    }\n\n    const qrCodeDataUrl = await QRCode.toDataURL(qrData, qrCodeOptions)\n\n    // Convertir base64 en Buffer pour ImageKit\n    const base64Data = qrCodeDataUrl.replace(/^data:image\\/\\w+;base64,/, '')\n    const imageBuffer = Buffer.from(base64Data, 'base64')\n\n    // Upload sur ImageKit\n    let imageKitUrl: string | null = null\n    let imageKitFileId: string | null = null\n    let imageKitThumbnailUrl: string | null = null\n\n    try {\n      const imageKitResult = await uploadToImageKit({\n        file: imageBuffer,\n        fileName: `qrcode-${code}-${Date.now()}.png`,\n        folder: \"/qrcodes\",\n        tags: [\"qrcode\", \"eventmaster\", validatedData.type.toLowerCase()],\n      })\n\n      imageKitUrl = imageKitResult.url\n      imageKitFileId = imageKitResult.fileId\n      imageKitThumbnailUrl = imageKitResult.thumbnailUrl\n    } catch (imageKitError) {\n      console.error(\"Erreur ImageKit, utilisation du fallback base64:\", imageKitError)\n      // En cas d'erreur ImageKit, on continue avec base64\n    }\n\n    // Préparer les données à stocker\n    const qrCodeData = {\n      name: validatedData.name,\n      url: qrData,\n      color: validatedData.color || \"#000000\",\n      backgroundColor: validatedData.backgroundColor || \"#FFFFFF\",\n      image: qrCodeDataUrl, // Garder base64 en fallback\n      imageKitUrl: imageKitUrl,\n      imageKitFileId: imageKitFileId,\n      imageKitThumbnailUrl: imageKitThumbnailUrl,\n      ...validatedData.data,\n    }\n\n    // Créer le QR code dans la base de données\n    const qrCode = await db.qrCode.create({\n      data: {\n        code: code!,\n        type: validatedData.type,\n        data: qrCodeData,\n        eventId: validatedData.eventId || null,\n        guestId: validatedData.guestId || null,\n        folderId: validatedData.folderId || null,\n        userId: userId,\n        scanned: false,\n      },\n      include: {\n        event: {\n          select: {\n            id: true,\n            name: true,\n          }\n        },\n        folder: {\n          select: {\n            id: true,\n            name: true,\n          }\n        }\n      }\n    })\n\n    return NextResponse.json({\n      success: true,\n      message: \"QR code généré avec succès\",\n      qrCode: {\n        id: qrCode.id,\n        code: qrCode.code,\n        name: validatedData.name,\n        type: qrCode.type,\n        image: imageKitUrl || qrCodeDataUrl, // Préférer ImageKit si disponible\n        imageKitUrl: imageKitUrl,\n        imageKitFileId: imageKitFileId,\n        url: qrData,\n        event: qrCode.event,\n        folder: qrCode.folder,\n        createdAt: qrCode.createdAt.toISOString(),\n      }\n    }, { status: 201 })\n\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: error.errors[0].message,\n          details: error.errors \n        },\n        { status: 400 }\n      )\n    }\n\n    if (error instanceof Prisma.PrismaClientKnownRequestError) {\n      if (error.code === 'P2002') {\n        return NextResponse.json(\n          { success: false, error: \"Un QR code avec ce code existe déjà\" },\n          { status: 409 }\n        )\n      }\n      if (error.code === 'P1001') {\n        return NextResponse.json(\n          { success: false, error: \"Impossible de se connecter à la base de données\" },\n          { status: 503 }\n        )\n      }\n    }\n\n    console.error(\"Erreur lors de la génération du QR code:\", error)\n    return NextResponse.json(\n      { success: false, error: \"Une erreur est survenue lors de la génération du QR code\" },\n      { status: 500 }\n    )\n  }\n}\n\n// GET - Récupérer les QR codes de l'utilisateur\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await auth()\n    \n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { success: false, error: \"Non authentifié\" },\n        { status: 401 }\n      )\n    }\n\n    const userId = session.user.id\n    const { searchParams } = new URL(request.url)\n    const folderId = searchParams.get('folderId')\n    const eventId = searchParams.get('eventId')\n\n    const where: Prisma.QrCodeWhereInput = {\n      userId,\n    }\n\n    if (folderId) {\n      where.folderId = folderId\n    }\n\n    if (eventId) {\n      where.eventId = eventId\n    }\n\n    const qrCodes = await db.qrCode.findMany({\n      where,\n      include: {\n        event: {\n          select: {\n            id: true,\n            name: true,\n            date: true,\n          }\n        },\n        folder: {\n          select: {\n            id: true,\n            name: true,\n            color: true,\n          }\n        },\n        guest: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n          }\n        }\n      },\n      orderBy: {\n        createdAt: 'desc'\n      }\n    })\n\n    const formattedQRCodes = qrCodes.map(qr => {\n      const qrData = qr.data as any\n      // Utiliser ImageKit si disponible, sinon base64\n      const imageUrl = qrData?.imageKitUrl || qrData?.image || \"\"\n      \n      return {\n        id: qr.id,\n        code: qr.code,\n        name: qrData?.name || \"QR Code\",\n        type: qr.type,\n        scanned: qr.scanned,\n        scannedAt: qr.scannedAt?.toISOString() || null,\n        createdAt: qr.createdAt.toISOString(),\n        imageUrl: imageUrl,\n        imageKitFileId: qrData?.imageKitFileId || null,\n        event: qr.event,\n        folder: qr.folder,\n        guest: qr.guest,\n      }\n    })\n\n    return NextResponse.json({\n      success: true,\n      qrCodes: formattedQRCodes\n    }, { status: 200 })\n\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération des QR codes:\", error)\n    return NextResponse.json(\n      { success: false, error: \"Une erreur est survenue\" },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}